
原始版本

//event.target 返回事件源对象（返回事件被分派的对象。）
//event.currentTarget （一般为父系对象）返回当前正在调用其事件侦听器回调的对象。
//event.stopPropagation()当在 DOM 树中分派时，调用此方法可防止事件到达除当前对象以外的任何对象。


<body>
<ul id="ull">
    <li>001fgb</li>
    <li>002fdv</li>
    <li>003vxv</li>
</ul>
<input type="button" id="btn" />
<script>
window.onload = function(){
    var ull = document.getElementById("ull");
    var aLi = ull.getElementsByTagName("li");
    var oBtn = document.getElementById("btn");
    var iNow = 4;

    for(var i=0; i<aLi.length;i++){
        aLi[i].onmouseover = function(){
            this.style.background = "red";
        }
        aLi[i].onmouseout = function(){
            this.style.background = ""
        }
    }
    oBtn.onclick = function(){
    iNow ++;
    var oLi = document.createElement("li");
    oLi.innerHTML = 1111 *iNow;
    oUl.appendChild(oLi);
  }

}
</script>
</body>

利用事件委托
<script>
window.onload = function(){
    var ull = document.getElementById("ull");
    //var aLi = ull.getElementsByTagName("li");
/* 此时要用到的事件源 :event 对象
事件源不管在哪个事件中，只要你操作的那个元素就是事件源。
ie:window.event.srcElement
标准下:event.target
nodeName : 找到元素的标签名
 */
 ull.onmouseover = function(ev){
 var ev = ev||window.event;
 var target = ev.target||ev.srcElement;
 //alert(target.innerHTML);
     if(target.nodeName.toLowerCase()=="li"){
         target.style.background="red";
     }
 }
 ull.onmouseout = function(ev){
     var ev = ev||window.event;
     var target = ev.target || ev.srcElement;
     // alert(target.innerHTML);
     if(target.nodeName.toLowerCase()=="li"){
         target.style.background="";
     }
 }
    oBtn.onclick = function(){
    iNow ++;
    var oLi = document.createElement("li");
    oLi.innerHTML = 1111 *iNow;
    oUl.appendChild(oLi);
}
</script>
